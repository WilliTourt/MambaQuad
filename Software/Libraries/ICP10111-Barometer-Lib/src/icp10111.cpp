/**
 * @file icp10111.cpp
 * @brief ICP10111 Pressure and Temperature Sensor Driver Implementation
 * 
 * This file contains the implementation of the ICP10111 class methods
 * for interfacing with the ICP10111 pressure and temperature sensor.
 * 
 * @author WilliTourt willitourt@foxmail.com
 * @version 1.0
 * @date 2025.12.02
 * 
 * @note Comments are mostly generated by AI
 * 
 * @changelog:
 * - (See header file for changes)
 */

#include "icp10111.h"
#include <cstring>
#include <cmath>

#ifdef __DMA_H__
#include "dma.h"
#endif



/**
 * @brief Write data to sensor via I2C
 * 
 * Supports both DMA and polling modes for I2C transmission.
 * 
 * @param data Pointer to data buffer
 * @param len Length of data to write
 * @return ICP10111_Status Status of write operation
 */
ICP10111::ICP10111_Status ICP10111::_write(uint8_t *data, uint8_t len) {
    HAL_StatusTypeDef status;

    if (_i2c_dmatx_enabled) {
        status = HAL_I2C_Master_Transmit_DMA(_hi2c, ICP10111_ADDR, data, len);
    } else {
        status = HAL_I2C_Master_Transmit(_hi2c, ICP10111_ADDR, data, len, ICP10111_I2C_TIMEOUT_MS);
    }

    if (status == HAL_OK) {
        return ICP10111_Status::OK;
    } else {
        return ICP10111_Status::ERROR_I2C;
    }
}

/**
 * @brief Read data from sensor via I2C
 * 
 * Supports both DMA and polling modes for I2C reception.
 * 
 * @param data Pointer to data buffer
 * @param len Length of data to read
 * @return ICP10111_Status Status of read operation
 */
ICP10111::ICP10111_Status ICP10111::_read(uint8_t *data, uint8_t len) {
    HAL_StatusTypeDef status;

    if (_i2c_dmarx_enabled) {
        status = HAL_I2C_Master_Receive_DMA(_hi2c, (ICP10111_ADDR | 0x01), data, len);
    } else {
        status = HAL_I2C_Master_Receive(_hi2c, (ICP10111_ADDR | 0x01), data, len, ICP10111_I2C_TIMEOUT_MS);
    }

    if (status == HAL_OK) {
        return ICP10111_Status::OK;
    } else {
        return ICP10111_Status::ERROR_I2C;
    }
}

/**
 * @brief Perform CRC8 check on data
 * 
 * Implements CRC8 polynomial check for data integrity verification.
 * 
 * @param toCheck Pointer to data to check
 * @param len Length of data to check
 * @param answer Expected CRC8 value
 * @return ICP10111_Status Status of CRC check
 */
ICP10111::ICP10111_Status ICP10111::_crc8(uint8_t *toCheck, uint8_t len, uint8_t answer) {
    if (!_crc8_enabled) { return ICP10111_Status::OK; }

    uint8_t crc = 0xFF;

    for (uint8_t i = 0; i < len; i++) {
        crc ^= toCheck[i];
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 0x80) {
                crc = (crc << 1) ^ ICP10111_CRC8_POLYNOMIAL;
            } else {
                crc <<= 1;
            }
        }
    }

    if (crc == answer) {
        return ICP10111_Status::OK;
    } else {
        return ICP10111_Status::ERROR_CRC;
    }
}



/**
 * @brief Construct a new ICP10111 object
 * 
 * Initializes the sensor with specified parameters and detects DMA capabilities.
 * 
 * @param hi2c Pointer to I2C handle
 * @param mode Measurement mode
 * @param seq Data sequence
 * @param enable_crc8 Enable CRC8 check
 */
ICP10111::ICP10111(I2C_HandleTypeDef *hi2c,
                   ICP10111_MeasurementMode mode,
                   ICP10111_DataSequence seq,
                   bool enable_crc8) :
                   _hi2c(hi2c),
                   _id(0),
                   _mode(mode),
                   _seq(seq),
                   _raw_pressure(0),
                   _raw_temperature(0),
                   _temperature(0.0f),
                   _pressure(0.0f),
                   _measurement_state(ICP10111_MeasurementState::IDLE),
                   _measurement_start_timestamp(0),
                   _crc8_enabled(enable_crc8) {

    if (_hi2c->hdmatx != NULL) {
        _i2c_dmatx_enabled = true;
    }
    if (_hi2c->hdmarx != NULL) {
        _i2c_dmarx_enabled = true;
    }

    switch (_mode) {
        case ICP10111_MeasurementMode::LOW_POWER:
            _busy_period_ms = ICP10111_BUSY_PERIOD_MS_LP;
            break;
        case ICP10111_MeasurementMode::NORMAL:
            _busy_period_ms = ICP10111_BUSY_PERIOD_MS_NM;
            break;
        case ICP10111_MeasurementMode::LOW_NOISE:
            _busy_period_ms = ICP10111_BUSY_PERIOD_MS_LN;
            break;
        case ICP10111_MeasurementMode::ULTRA_LOW_NOISE:
            _busy_period_ms = ICP10111_BUSY_PERIOD_MS_ULN;
            break;
        default:
            _busy_period_ms = ICP10111_BUSY_PERIOD_MS_NM;
            break;
    }

    memset(_otp_data, 0, sizeof(_otp_data));
}

/**
 * @brief Initialize the ICP10111 sensor
 * 
 * Performs the following initialization sequence:
 * 1. Check chip ID
 * 2. Reset the sensor
 * 3. Read OTP calibration data
 * 
 * @return ICP10111_Status Status of initialization
 */
ICP10111::ICP10111_Status ICP10111::begin() {

    #if ICP_USE_FREERTOS == 1
        if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
            ICP_TaskDelay(1);
        } else {
            HAL_Delay(1);
        }
    #else
        HAL_Delay(1);
    #endif

    ICP10111_Status status;

    status = _chkID();
    if (status != ICP10111_Status::OK) {
        return status;
    }

    status = reset();
    if (status != ICP10111_Status::OK) {
        return status;
    }

    status = _readOTP();
    return status;
}

/**
 * @brief Reset the ICP10111 sensor
 * 
 * Sends soft reset command to the sensor.
 * 
 * @return ICP10111_Status Status of reset operation
 */
ICP10111::ICP10111_Status ICP10111::reset() {
    uint8_t cmd[2] = { (uint8_t)(ICP10111_CMD_SOFTRST >> 8), (uint8_t)(ICP10111_CMD_SOFTRST & 0xFF) };
    ICP10111_Status status;

    status = _write(cmd, 2);

    #if ICP_USE_FREERTOS == 1
        if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
            ICP_TaskDelay(1);
        } else {
            HAL_Delay(1);
        }
    #else
        HAL_Delay(1);
    #endif

    return status;
}



/**
 * @brief Perform a measurement
 * 
 * Uses a state machine to handle the measurement process:
 * - IDLE state: Sends measurement command based on mode and sequence
 * - MEASURING state: Waits for completion and reads data
 * 
 * @return ICP10111_Status Status of measurement operation
 */
ICP10111::ICP10111_Status ICP10111::measure() {
    ICP10111_Status status;

    switch (_measurement_state) {
        case ICP10111_MeasurementState::IDLE: {
            uint8_t cmd[2];

            switch (_mode) {
                case ICP10111_MeasurementMode::LOW_POWER: {
                    if (_seq == ICP10111_DataSequence::P_FIRST) {
                        cmd[0] = (uint8_t)(ICP10111_CMD_MEASURE_LP_P_FIRST >> 8);
                        cmd[1] = (uint8_t)(ICP10111_CMD_MEASURE_LP_P_FIRST & 0xFF);
                    } else {
                        cmd[0] = (uint8_t)(ICP10111_CMD_MEASURE_LP_T_FIRST >> 8);
                        cmd[1] = (uint8_t)(ICP10111_CMD_MEASURE_LP_T_FIRST & 0xFF);
                    }
                    break;
                }
                case ICP10111_MeasurementMode::NORMAL: {
                    if (_seq == ICP10111_DataSequence::P_FIRST) {
                        cmd[0] = (uint8_t)(ICP10111_CMD_MEASURE_NM_P_FIRST >> 8);
                        cmd[1] = (uint8_t)(ICP10111_CMD_MEASURE_NM_P_FIRST & 0xFF);
                    } else {
                        cmd[0] = (uint8_t)(ICP10111_CMD_MEASURE_NM_T_FIRST >> 8);
                        cmd[1] = (uint8_t)(ICP10111_CMD_MEASURE_NM_T_FIRST & 0xFF);
                    }
                    break;
                }
                case ICP10111_MeasurementMode::LOW_NOISE: {
                    if (_seq == ICP10111_DataSequence::P_FIRST) {
                        cmd[0] = (uint8_t)(ICP10111_CMD_MEASURE_LN_P_FIRST >> 8);
                        cmd[1] = (uint8_t)(ICP10111_CMD_MEASURE_LN_P_FIRST & 0xFF);
                    } else {
                        cmd[0] = (uint8_t)(ICP10111_CMD_MEASURE_LN_T_FIRST >> 8);
                        cmd[1] = (uint8_t)(ICP10111_CMD_MEASURE_LN_T_FIRST & 0xFF);
                    }
                    break;
                }
                case ICP10111_MeasurementMode::ULTRA_LOW_NOISE: {
                    if (_seq == ICP10111_DataSequence::P_FIRST) {
                        cmd[0] = (uint8_t)(ICP10111_CMD_MEASURE_ULN_P_FIRST >> 8);
                        cmd[1] = (uint8_t)(ICP10111_CMD_MEASURE_ULN_P_FIRST & 0xFF);
                    } else {
                        cmd[0] = (uint8_t)(ICP10111_CMD_MEASURE_ULN_T_FIRST >> 8);
                        cmd[1] = (uint8_t)(ICP10111_CMD_MEASURE_ULN_T_FIRST & 0xFF);
                    }
                    break;
                }
                default:
                    return ICP10111_Status::ERROR;
            }

            status = _write(cmd, 2);
            if (status != ICP10111_Status::OK) {
                return status;
            }

            _measurement_start_timestamp = HAL_GetTick();
            _measurement_state = ICP10111_MeasurementState::MEASURING;
            return ICP10111_Status::OK;
        }

        case ICP10111_MeasurementState::MEASURING: {
            uint32_t elapsed = HAL_GetTick() - _measurement_start_timestamp;
            if (elapsed < _busy_period_ms) {
                return ICP10111_Status::BUSY;
            }

            uint8_t rcvd[9];
            status = _read(rcvd, 9);
            if (status != ICP10111_Status::OK) {
                _measurement_state = ICP10111_MeasurementState::IDLE;
                return status;
            }

            if (_crc8(&rcvd[0], 2, rcvd[2]) != ICP10111_Status::OK) {
                _measurement_state = ICP10111_MeasurementState::IDLE;
                return ICP10111_Status::ERROR_CRC;
            }

            if (_crc8(&rcvd[3], 2, rcvd[5]) != ICP10111_Status::OK) {
                _measurement_state = ICP10111_MeasurementState::IDLE;
                return ICP10111_Status::ERROR_CRC;
            }

            if (_crc8(&rcvd[6], 2, rcvd[8]) != ICP10111_Status::OK) {
                _measurement_state = ICP10111_MeasurementState::IDLE;
                return ICP10111_Status::ERROR_CRC;
            }

            if (_seq == ICP10111_DataSequence::P_FIRST) {
                _raw_pressure = ((uint32_t)rcvd[0] << 16) |
                                ((uint32_t)rcvd[1] << 8)  |
                                ((uint32_t)rcvd[3]);
                _raw_temperature = ((uint16_t)rcvd[6] << 8) |
                                   ((uint16_t)rcvd[7]);
            } else {
                _raw_temperature = ((uint16_t)rcvd[0] << 8) |
                                   ((uint16_t)rcvd[1]);
                _raw_pressure = ((uint32_t)rcvd[3] << 16) |
                                ((uint32_t)rcvd[4] << 8)  |
                                ((uint32_t)rcvd[6]);
            }

            _measurement_state = ICP10111_MeasurementState::IDLE;
            return ICP10111_Status::DRDY;
        }

        default:
            return ICP10111_Status::ERROR;
    }
}



/* Below are original data conversion implementation in datasheet ********************************

    void init_base(struct inv_invpres * s, short *otp)  
    { 
        int i; 

        for(i = 0; i < 4; i++) 
         s->sensor_constants[i] = (float)otp[i]; 

        s->p_Pa_calib[0] = 45000.0; 
        s->p_Pa_calib[1] = 80000.0; 
        s->p_Pa_calib[2] = 105000.0; 
        s->LUT_lower = 3.5 * (1<<20); 
        s->LUT_upper = 11.5 * (1<<20); 
        s->quadr_factor = 1 / 16777216.0; 
        s->offst_factor = 2048.0; 
    }

    // p_LSB -- Raw pressure data from sensor 
    // T_LSB -- Raw temperature data from sensor 
    int inv_invpres_process_data(struct inv_invpres * s, int p_LSB, int T_LSB,  
    float * pressure, float * temperature)  
    { 
        float t; 
        float s1,s2,s3; 
        float in[3]; 
        float out[3]; 
        float A,B,C; 

        t = (float)(T_LSB - 32768); 
        s1 = s->LUT_lower + (float)(s->sensor_constants[0] * t * t) * s->quadr_factor; 
        s2 = s->offst_factor * s->sensor_constants[3] + (float)(s->sensor_constants[1] * t * t) * s->quadr_factor; 
        s3 = s->LUT_upper + (float)(s->sensor_constants[2] * t * t) * s->quadr_factor; 
        in[0] = s1; 
        in[1] = s2; 
        in[2] = s3; 

        calculate_conversion_constants(s, s->p_Pa_calib, in, out); 
        A = out[0]; 
        B = out[1]; 
        C = out[2]; 

        *pressure = A + B / (C + p_LSB); 
        *temperature = -45.f + 175.f/65536.f * T_LSB; 

        return 0; 
    } 
    
    // p_Pa -- List of 3 values corresponding to applied pressure in Pa 
    // p_LUT -- List of 3 values corresponding to the measured p_LUT values at the applied pressures. 
    void calculate_conversion_constants(struct inv_invpres * s, float *p_Pa,  
    float *p_LUT, float *out)  
    { 
        float A,B,C; 

        C = (p_LUT[0] * p_LUT[1] * (p_Pa[0] - p_Pa[1]) + 
             p_LUT[1] * p_LUT[2] * (p_Pa[1] - p_Pa[2]) + 
             p_LUT[2] * p_LUT[0] * (p_Pa[2] - p_Pa[0])) / 
             (p_LUT[2] * (p_Pa[0] - p_Pa[1]) + 
             p_LUT[0] * (p_Pa[1] - p_Pa[2]) + 
             p_LUT[1] * (p_Pa[2] - p_Pa[0])); 
        A = (p_Pa[0] * p_LUT[0] - p_Pa[1] * p_LUT[1] - (p_Pa[1] - p_Pa[0]) * C) / (p_LUT[0] - p_LUT[1]); 
        B = (p_Pa[0] - A) * (p_LUT[0] + C); 

        out[0] = A; 
        out[1] = B; 
        out[2] = C; 
    } 

*/
/**
 * @brief Convert raw sensor readings to physical units
 *
 * This routine converts the raw ADC readings read from the ICP10111 into
 * physical temperature (degrees Celsius) and pressure (Pascal) using the
 * calibration constants read from the sensor OTP memory.
 *
 * It updates the member fields `_temperature` and `_pressure` based on the
 * datasheet conversion algorithm (quadratic temperature dependency and LUT
 * calibration constants A, B, C).
 *
 * Note: `_otp_data` must contain valid calibration words (read previously
 * via `_readOTP`) before calling this function. The resulting pressure is in
 * Pascals and temperature in Â°C.
 */
void ICP10111::convertData() {
    _temperature = -45.0f + 175.0f * _raw_temperature / 65536.0f;

    float c1 = static_cast<float>(_otp_data[0]);
    float c2 = static_cast<float>(_otp_data[1]);
    float c3 = static_cast<float>(_otp_data[2]);
    float c4 = static_cast<float>(_otp_data[3]);

    float t = static_cast<float>(_raw_temperature) - 32768.0f;

    float t_squared = t * t;
    float s1 = ICP10111_LUT_LOWER + c1 * t_squared * ICP10111_QUADR_FACTOR;
    float s2 = ICP10111_OFFSET_FACTOR * c4 + c2 * t_squared * ICP10111_QUADR_FACTOR;
    float s3 = ICP10111_LUT_UPPER + c3 * t_squared * ICP10111_QUADR_FACTOR;

    float p0 = ICP10111_P_PA_CALIB_A;
    float p1 = ICP10111_P_PA_CALIB_B;
    float p2 = ICP10111_P_PA_CALIB_C;
    
    float numerator_C = s1 * s2 * (p0 - p1) + 
                        s2 * s3 * (p1 - p2) + 
                        s3 * s1 * (p2 - p0);
    float denominator_C = s3 * (p0 - p1) + 
                          s1 * (p1 - p2) + 
                          s2 * (p2 - p0);
    float C = numerator_C / denominator_C;

    float numerator_A = p0 * s1 - p1 * s2 - (p1 - p0) * C;
    float denominator_A = s1 - s2;
    float A = numerator_A / denominator_A;

    float B = (p0 - A) * (s1 + C);

    _pressure = A + B / (C + static_cast<float>(_raw_pressure));
}

float ICP10111::getAltitude(float pressure_sea_level) {
    float altitude;
    altitude = 44330.0f * (1.0f - powf((_pressure / pressure_sea_level), 0.1903f));
    return altitude;
}

/**
 * @brief Compute altitude from pressure using measured temperature
 *
 * This function uses the barometric formula with the measured temperature to
 * compute a more accurate altitude estimate than the standard approximation.
 *
 * @param pressure_sea_level Reference sea-level pressure in Pascals
 * @return Altitude in meters
 *
 * The formula assumes a linear temperature lapse rate and uses the universal
 * gas constant for dry air. `_temperature` and `_pressure` must be up-to-date
 * (i.e. after `convertData()`/`measure()`).
 */
float ICP10111::getAltitudeWithTemp(float pressure_sea_level) {
    float L = 0.0065f;
    float R = 287.05f;
    float g = 9.80665f;
    
    float T = _temperature + 273.15f;
    
    return (T / L) * (powf(_pressure / pressure_sea_level, -(R * L) / g) - 1.0f);
}


/**
 * @brief Read and validate the sensor chip ID
 *
 * Sends the READID command to the sensor, reads back the 2-byte ID plus CRC,
 * verifies the CRC, and checks the product code against the expected
 * `ICP10111_SPEC_PRODUCT_CODE`.
 *
 * On success the internal `_id` field is set to the 16-bit ID value.
 *
 * @return ICP10111_Status::OK on success, or an appropriate error code
 */
ICP10111::ICP10111_Status ICP10111::_chkID() {
    uint8_t cmd[2] = { (uint8_t)(ICP10111_CMD_READID >> 8), (uint8_t)(ICP10111_CMD_READID & 0xFF) };
    uint8_t rcvd[3];
    ICP10111_Status status;

    status = _write(cmd, 2);
    if (status != ICP10111_Status::OK) {
        return status;
    }
    status = _read(rcvd, 3);
    if (status != ICP10111_Status::OK) {
        return status;
    }

    if (_crc8(rcvd, 2, rcvd[2]) != ICP10111_Status::OK) {
        return ICP10111_Status::ERROR_CRC;
    }

    if ((rcvd[1] & 0x3F) != ICP10111_SPEC_PRODUCT_CODE) {
        return ICP10111_Status::ERROR_ID;
    }

    _id = (rcvd[0] << 8) | rcvd[1];
    return ICP10111_Status::OK;
}

/**
 * @brief Read OTP calibration words from the sensor
 *
 * This routine performs the required setup transaction to enable OTP reads,
 * then issues the OTP read command repeatedly to retrieve the 4 calibration
 * words. Each 16-bit word is returned as two bytes followed by a CRC byte
 * which is verified before storing the data into `_otp_data`.
 *
 * @return ICP10111_Status::OK on success, or an error code if any I2C or CRC
 *         operation fails.
 */
ICP10111::ICP10111_Status ICP10111::_readOTP() {

    ICP10111_Status status;

    status = _write(const_cast<uint8_t*>(_otp_cmd), ICP10111_CMD_READOTP_SETUP_LENGTH);
    if (status != ICP10111_Status::OK) {
        return status;
    }

    uint8_t cmd[2] = { (uint8_t)(ICP10111_CMD_READOTP >> 8), (uint8_t)(ICP10111_CMD_READOTP & 0xFF) };
    uint8_t rcvd[3];
    for (uint8_t i = 0; i < 4; i++) {
        status = _write(cmd, 2);
        if (status != ICP10111_Status::OK) {
            return status;
        }

        status = _read(rcvd, 3);
        if (status != ICP10111_Status::OK) {
            return status;
        }

        if (_crc8(rcvd, 2, rcvd[2]) != ICP10111_Status::OK) {
            return ICP10111_Status::ERROR_CRC;
        }

        _otp_data[i] = (rcvd[0] << 8) | rcvd[1];
    }

    return ICP10111_Status::OK;
}
