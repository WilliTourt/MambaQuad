/**
 * @file icp10111.h
 * @brief ICP10111 pressure & temperature sensor driver - public header

 * This header exposes a lightweight C++ driver for the ICP10111 sensor.
 * It depends on STM32Cube HAL I2C and provides functions to initialize the
 * sensor, perform measurements, convert raw values to human-readable units,
 * and compute altitude estimates. The driver optionally validates CRC8 and
 * supports DMA-capable HAL I2C handles.
 *
 * Usage summary:
 * - Include this header in C++ files that have access to `I2C_HandleTypeDef`.
 * - Create an `ICP10111` instance with an I2C handle and desired mode.
 * - Call `begin()` to verify ID, reset and load OTP calibration.
 * - Use `measure()` then `convertData()` (or `getPressure()/getTemperature()`)
 *   to obtain calibrated readings.
 *
 * Notes:
 * - This driver requires one of the STM32 HAL headers to be included (checked
 *   at compile-time). It also requires `HAL_I2C_MODULE_ENABLED`.
 * - Default I2C address and commands are defined in this header.
 *
 * @author WilliTourt willitourt@foxmail.com
 * @version 1.0
 * @date 2025.12.02
 * 
 * @note Comments are mostly generated by AI
 * 
 * @changelog:
 * - 2025.12.02: Initial release, some of the DMA related interrupts are not
 *               implemented, so DMA features won't work.
 * 
 */

#pragma once



#define ICP_USE_FREERTOS true // Set to 1 to enable FreeRTOS delays, 0 for HAL_Delay (blocking)



#include "main.h"
#ifdef HAL_I2C_MODULE_ENABLED
    #include "i2c.h"
#else
    #error "At least one IIC port should be opened"
#endif

#if ICP_USE_FREERTOS == 1
    #include "FreeRTOS.h"
    #include "task.h"
    #define ICP_TaskDelay(ms) vTaskDelay(pdMS_TO_TICKS(ms))
#endif

#if !defined(__STM32F1xx_HAL_H) && \
    !defined(__STM32F4xx_HAL_H) && \
    !defined(__STM32F7xx_HAL_H) && \
    !defined(__STM32H7xx_HAL_H) && \
    !defined(__STM32L4xx_HAL_H) && \
    !defined(__STM32G0xx_HAL_H) && \
    !defined(__STM32WBxx_HAL_H) && \
    !defined(__STM32WLxx_HAL_H)
#error "This icp10111 library can only be used with STM32Cube HAL drivers"
#endif

// ICP10111 I2C address
#define ICP10111_ADDR 0xC6U ///< I2C address: 0110 0011 << 1

// ICP10111 Product Code
#define ICP10111_SPEC_PRODUCT_CODE 0x08U ///< Expected product code for verification

// I2C Communication Timeout
#define ICP10111_I2C_TIMEOUT_MS 100 ///< I2C communication timeout in milliseconds

// ICP10111 Command Definitions
#define ICP10111_CMD_SOFTRST 0x805DU ///< Soft reset command
#define ICP10111_CMD_READID  0xEFC8U ///< Read chip ID command

// OTP (One-Time Programmable) Read Commands
#define ICP10111_CMD_READOTP_SETUP { 0xC5U, 0x95U, 0x00U, 0x66U, 0x9CU } ///< OTP read setup sequence
#define ICP10111_CMD_READOTP_SETUP_LENGTH 5 ///< Length of OTP read setup sequence
#define ICP10111_CMD_READOTP 0xC7F7U ///< Read OTP command

// Measurement Commands (Temperature First / Pressure First)
#define ICP10111_CMD_MEASURE_LP_T_FIRST  0x609CU ///< Low power mode, temperature first
#define ICP10111_CMD_MEASURE_LP_P_FIRST  0x401AU ///< Low power mode, pressure first
#define ICP10111_CMD_MEASURE_NM_T_FIRST  0x6825U ///< Normal mode, temperature first
#define ICP10111_CMD_MEASURE_NM_P_FIRST  0x48A3U ///< Normal mode, pressure first
#define ICP10111_CMD_MEASURE_LN_T_FIRST  0x70DFU ///< Low noise mode, temperature first
#define ICP10111_CMD_MEASURE_LN_P_FIRST  0x5059U ///< Low noise mode, pressure first
#define ICP10111_CMD_MEASURE_ULN_T_FIRST 0x7866U ///< Ultra low noise mode, temperature first
#define ICP10111_CMD_MEASURE_ULN_P_FIRST 0x58E0U ///< Ultra low noise mode, pressure first

// CRC8 Configuration
#define ICP10111_CRC8_POLYNOMIAL 0x31U ///< CRC8 polynomial for data integrity check

// Measurement Busy Periods (milliseconds)
#define ICP10111_BUSY_PERIOD_MS_LP 2   ///< Low power mode busy period
#define ICP10111_BUSY_PERIOD_MS_NM 7   ///< Normal mode busy period
#define ICP10111_BUSY_PERIOD_MS_LN 24  ///< Low noise mode busy period
#define ICP10111_BUSY_PERIOD_MS_ULN 95 ///< Ultra low noise mode busy period

/* Some magic numbers from the datasheet ******************************/
#define ICP10111_LUT_LOWER 3.5 * (1 << 20) ///< Lower LUT value for pressure calculation
#define ICP10111_LUT_UPPER 11.5 * (1 << 20) ///< Upper LUT value for pressure calculation
#define ICP10111_QUADR_FACTOR 1.0f / 16777216.0f ///< Quadratic factor for pressure calculation
#define ICP10111_OFFSET_FACTOR 2048.0f ///< Offset factor for pressure calculation
#define ICP10111_P_PA_CALIB_A 45000.0f ///< Pressure calibration point A (Pa)
#define ICP10111_P_PA_CALIB_B 80000.0f ///< Pressure calibration point B (Pa)
#define ICP10111_P_PA_CALIB_C 105000.0f ///< Pressure calibration point C (Pa)



/**
 * @class ICP10111
 * @brief Driver for ICP10111 pressure and temperature sensor
 * 
 * This class provides methods to initialize, configure and read data
 * from the ICP10111 pressure and temperature sensor. It supports I2C communication
 * and includes built-in calibration and data conversion algorithms.
 */
class ICP10111 {
    public:
        /**
         * @brief Status codes returned by ICP10111 functions
         */
        enum class ICP10111_Status {
            OK,         ///< Operation successful
            BUSY,       ///< Sensor is busy with measurement
            DRDY,       ///< Data ready for reading

            ERROR,      ///< General error occurred
            ERROR_ID,   ///< Chip ID verification failed
            ERROR_I2C,  ///< I2C communication error
            ERROR_CRC   ///< CRC check failed
        };

        /**
         * @brief Measurement modes of the ICP10111 sensor
         */
        enum class ICP10111_MeasurementMode {
            LOW_POWER,      ///< Low power mode (fastest, lowest accuracy)
            NORMAL,         ///< Normal mode (balanced power and accuracy)
            LOW_NOISE,      ///< Low noise mode (higher accuracy)
            ULTRA_LOW_NOISE ///< Ultra low noise mode (highest accuracy)
        };

        /**
         * @brief Data sequence for measurement results
         */
        enum class ICP10111_DataSequence {
            T_FIRST,    ///< Temperature data first in measurement sequence
            P_FIRST     ///< Pressure data first in measurement sequence
        };

        /**
         * @brief Measurement state of the sensor
         */
        enum class ICP10111_MeasurementState {
            IDLE,       ///< Sensor is idle, ready for new measurement
            MEASURING   ///< Sensor is currently measuring
        };

        /**
         * @brief Construct a new ICP10111 object
         * 
         * @param hi2c Pointer to I2C handle
         * @param mode Measurement mode (default: NORMAL)
         * @param seq Data sequence (default: P_FIRST)
         * @param enable_crc8 Enable CRC8 check (default: true)
         */
        ICP10111(I2C_HandleTypeDef *hi2c,
                 ICP10111_MeasurementMode mode = ICP10111_MeasurementMode::NORMAL,
                 ICP10111_DataSequence seq = ICP10111_DataSequence::P_FIRST,
                 bool enable_crc8 = true);

        /**
         * @brief Initialize the ICP10111 sensor
         * 
         * Performs chip ID verification, soft reset, and reads OTP data.
         * 
         * @return ICP10111_Status Status of initialization
         */
        ICP10111_Status begin();

        /**
         * @brief Reset the ICP10111 sensor
         * 
         * Performs a soft reset of the sensor.
         * 
         * @return ICP10111_Status Status of reset operation
         */
        ICP10111_Status reset();

        /**
         * @brief Perform a measurement
         * 
         * Starts a measurement and waits for completion. Uses state machine
         * to handle measurement process.
         * 
         * @return ICP10111_Status Status of measurement operation
         */
        ICP10111_Status measure();
        
        // ICP10111_Status startMeasurement();
        // ICP10111_Status pollMeasurement();

        /**
         * @brief Converts raw pressure and temperature data to calibrated physical values using OTP calibration data.
         */
        void convertData();

        /**
         * @brief Get the raw pressure value
         * 
         * @return uint32_t Raw pressure value from sensor
         */
        inline uint32_t getRawPressure() { return _raw_pressure; }
        
        /**
         * @brief Get the raw temperature value
         * 
         * @return uint16_t Raw temperature value from sensor
         */
        inline uint16_t getRawTemperature() { return _raw_temperature; }
        
        /**
         * @brief Get the calibrated temperature value
         * 
         * @return float Temperature in degrees Celsius
         */
        inline float getTemperature() { return _temperature; }
        
        /**
         * @brief Get the calibrated pressure value
         * 
         * @return float Pressure in Pascals
         */
        inline float getPressure() { return _pressure; }

        /**
         * @brief Get converted altitude value
         * 
         * @param pressure_sea_level Pressure at sea level in Pascals (default: 101325)
         * @return float Altitude in meters
         */
        float getAltitude(float pressure_sea_level = 101325.0f);

        /**
         * @brief Get converted altitude value with temperature compensation
         * 
         * @param pressure_sea_level Pressure at sea level in Pascals (default: 101325)
         * @return float Altitude in meters
         */
        float getAltitudeWithTemp(float pressure_sea_level = 101325.0f);

    private:
        /**
         * @brief Write data to sensor via I2C
         * 
         * @param data Pointer to data buffer
         * @param len Length of data to write
         * @return ICP10111_Status Status of write operation
         */
        ICP10111_Status _write(uint8_t *data, uint8_t len);
        
        /**
         * @brief Read data from sensor via I2C
         * 
         * @param data Pointer to data buffer
         * @param len Length of data to read
         * @return ICP10111_Status Status of read operation
         */
        ICP10111_Status _read(uint8_t *data, uint8_t len);
        
        /**
         * @brief Perform CRC8 check on data
         * 
         * @param toCheck Pointer to data to check
         * @param len Length of data to check
         * @param answer Expected CRC8 value
         * @return ICP10111_Status Status of CRC check
         */
        ICP10111_Status _crc8(uint8_t *toCheck, uint8_t len, uint8_t answer);

        /**
         * @brief Check sensor chip ID
         * 
         * @return ICP10111_Status Status of ID verification
         */
        ICP10111_Status _chkID();
        
        /**
         * @brief Read OTP (One-Time Programmable) calibration data
         * 
         * @return ICP10111_Status Status of OTP read operation
         */
        ICP10111_Status _readOTP();

        I2C_HandleTypeDef *_hi2c;          ///< I2C handle
        bool _i2c_dmatx_enabled = false;   ///< I2C DMA TX enabled flag
        bool _i2c_dmarx_enabled = false;   ///< I2C DMA RX enabled flag

        uint16_t _id;                       ///< Chip ID
        ICP10111_MeasurementMode _mode;     ///< Measurement mode
        ICP10111_DataSequence _seq;         ///< Data sequence
        
        uint32_t _raw_pressure;             ///< Raw pressure value
        uint16_t _raw_temperature;          ///< Raw temperature value
        float _temperature;                 ///< Calibrated temperature value
        float _pressure;                    ///< Calibrated pressure value

        const uint8_t _otp_cmd[ICP10111_CMD_READOTP_SETUP_LENGTH] = ICP10111_CMD_READOTP_SETUP; ///< OTP read command sequence
        uint16_t _otp_data[4];              ///< OTP calibration data

        ICP10111_MeasurementState _measurement_state;       ///< Current measurement state
        uint32_t _measurement_start_timestamp;              ///< Measurement start timestamp
        uint8_t _busy_period_ms;                           ///< Busy period for current mode

        bool _crc8_enabled;                 ///< CRC8 check enabled flag
};
